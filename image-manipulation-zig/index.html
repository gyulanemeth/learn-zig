<html>
    <head>
        <title>zig image manipulation test</title>
        <style>
          body {
            margin: 0;
            padding: 0;
          }
          td {
            padding: 5px;
          }
        </style>
    </head>
    <body>
        <table>
            <tr>
                <td>Javascript</td>
                <td><button id="invert-js">Invert</button></td>
                <td><button id="grayscale-js">Grayscale</button></td>
                <td><button id="blur-js">Blur</button></td>
                <td><button id="sharpen-js">Sharpen</button></td>
                <td><button id="edge-js">Edge detection</button></td>
            </tr>
            <tr>
                <td>Zig WASM</td>
                <td><button id="invert-zig">Invert</button></td>
                <td><button id="grayscale-zig">Grayscale</button></td>
                <td><button id="blur-zig">Blur</button></td>
                <td><button id="sharpen-zig">Sharpen</button></td>
                <td><button id="edge-zig">Edge detection</button></td>
            </tr>
        </table>
        <div>
            
            
            
        </div>
        <div>
            <canvas id="canvas"></canvas>
        </div>
        <div>
            <span>Last exec. time:</span>
            <span id="exec-time"></span>
        </div>
        <script>
            const canvas = document.getElementById('canvas')
            const context = canvas.getContext('2d', { willReadFrequently: true })

            function loadImg(url) {
              return new Promise(resolve => {
                let img = new Image()
                img.crossOrigin = 'Anonymous'
                img.onload = () => resolve(img)
                img.src = url
              })
            }

            async function loadImgToCanvas(url) {
              const img = await loadImg(url)
              canvas.width = img.naturalWidth
              canvas.height = img.naturalHeight
              context.drawImage(img, 0, 0)
            }

            async function main() {
                const time1 = performance.now()

                await loadImgToCanvas('./lena.png')
                // await loadImgToCanvas('./valencia.jpeg')
                const time2 = performance.now()
                console.log('image to canvas', time2 - time1)

                let drawPixelCb = () => {}
                let drawPixelsDoneCb = () => {}

                const importObject = {
                    env: {
                        drawPixel: (rIdx, cIdx, r, g, b, a) => {
                            drawPixelCb(rIdx, cIdx, r, g, b, a)
                        },
                        drawPixelsDone: () => {
                            drawPixelsDoneCb()
                        }
                    }
                }

                const results = await WebAssembly.instantiateStreaming(fetch("./imgage-manipulation.wasm"), importObject)
                const wasmIface = results.instance.exports
                const time3 = performance.now()
                console.log('wasm load', time3 - time2)

                const imgData = context.getImageData(0, 0, canvas.width, canvas.height);
                const imgMemoryAddress = wasmIface.init(imgData.height, imgData.width)
                const time4 = performance.now()
                console.log('wasm - allocate memory', time4 - time3)

                const rowLength = imgData.width * 4
                for (let idx = 0; idx < imgData.data.length; idx += 4) {
                    const rIdx = Math.floor(idx / rowLength)
                    const cIdx = (idx % rowLength) / 4
                    const r = imgData.data[idx]
                    const g = imgData.data[idx + 1]
                    const b = imgData.data[idx + 2]
                    const a = imgData.data[idx + 3]

                    wasmIface.set_pixel(rIdx, cIdx, r, g, b, a)
                }

                const time5 = performance.now()
                console.log('pixels -> wasm', time4 - time3)

                function invert() {
                    const start = performance.now()

                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    const rowLength = imgData.width * 4
                    
                    drawPixelCb = (rIdx, cIdx, r, g, b, a) => {
                        const redIdx = rIdx * rowLength + cIdx * 4
                        imgData.data[redIdx] = r
                        imgData.data[redIdx + 1] = g
                        imgData.data[redIdx + 2] = b
                        imgData.data[redIdx + 3] = a
                    }

                    drawPixelsDoneCb = () => {
                        context.putImageData(imgData, 0, 0)
                        const execSpan = document.getElementById('exec-time')
                        execSpan.innerHTML = performance.now() - start
                    }
                    wasmIface.invert()
                }

                function invert2() {
                    const start = performance.now()

                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    const rowLength = imgData.width * 4
                    for (let idx = 0; idx < imgData.data.length; idx += 4) {
                        const r = 255 - imgData.data[idx]
                        const g = 255 - imgData.data[idx + 1]
                        const b = 255 - imgData.data[idx + 2]

                        imgData.data[idx] = r
                        imgData.data[idx + 1] = g
                        imgData.data[idx + 2] = b
                    }

                    context.putImageData(imgData, 0, 0)
                    const execSpan = document.getElementById('exec-time')
                    execSpan.innerHTML = performance.now() - start
                }

                function getPixelIndices(width, x, y) {
                    const rIdx = y * (width * 4) + x * 4
                    const gIdx = rIdx + 1
                    const bIdx = rIdx + 2
                    const aIdx = rIdx + 3

                    return [ rIdx, gIdx, bIdx, aIdx ]
                }

                function getPixel(imgData, x, y) {
                    const [ rIdx, gIdx, bIdx, aIdx ] = getPixelIndices(imgData.width, x, y)

                    return {
                        r: imgData.data[rIdx],
                        g: imgData.data[gIdx],
                        b: imgData.data[bIdx],
                        a: imgData.data[aIdx]
                    }
                }

                function setPixel(imgData, x, y, { r, g, b, a }) {
                    const [ rIdx, gIdx, bIdx, aIdx ] = getPixelIndices(imgData.width, x, y)

                    imgData.data[rIdx] = r
                    imgData.data[gIdx] = g
                    imgData.data[bIdx] = b
                    imgData.data[aIdx] = a
                }

                function toGrayscale() {
                    const start = performance.now()
                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    const rowLength = imgData.width * 4
                    
                    drawPixelCb = (rIdx, cIdx, r, g, b, a) => {
                        const redIdx = rIdx * rowLength + cIdx * 4
                        imgData.data[redIdx] = r
                        imgData.data[redIdx + 1] = g
                        imgData.data[redIdx + 2] = b
                        imgData.data[redIdx + 3] = a
                    }

                    drawPixelsDoneCb = () => {
                        context.putImageData(imgData, 0, 0)
                        const execSpan = document.getElementById('exec-time')
                        execSpan.innerHTML = performance.now() - start
                    }
                    wasmIface.to_grayscale()
                }

                function toGrayscale2() {
                    const start = performance.now()
                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    for (let rIdx = 0; rIdx < imgData.height; rIdx += 1) {
                        for (let cIdx = 0; cIdx < imgData.width; cIdx += 1) {
                            const pixel = getPixel(imgData, cIdx, rIdx)
                            const avg = Math.floor((pixel.r + pixel.g + pixel.b) / 3)
                            pixel.r = avg
                            pixel.g = avg
                            pixel.b = avg

                            setPixel(imgData, cIdx, rIdx, pixel)
                        }
                    }
                    context.putImageData(imgData, 0, 0)
                    const execSpan = document.getElementById('exec-time')
                    execSpan.innerHTML = performance.now() - start
                }

                function blur() {
                    const start = performance.now()
                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    wasmIface.blur()
                    const addr = wasmIface.currentImgAddress()
                    const imgArray = new Uint8ClampedArray(wasmIface.memory.buffer, addr, imgData.data.length)

                    const newImgData = new ImageData(imgArray, imgData.width, imgData.height)
                    context.putImageData(newImgData, 0, 0)
                    const execSpan = document.getElementById('exec-time')
                    execSpan.innerHTML = performance.now() - start
                }

                function sharpen() {
                    const start = performance.now()
                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    wasmIface.sharpen()
                    const addr = wasmIface.currentImgAddress()
                    const imgArray = new Uint8ClampedArray(wasmIface.memory.buffer, addr, imgData.data.length)

                    const newImgData = new ImageData(imgArray, imgData.width, imgData.height)
                    context.putImageData(newImgData, 0, 0)
                    const execSpan = document.getElementById('exec-time')
                    execSpan.innerHTML = performance.now() - start
                }

                function edgeDetection() {
                    const start = performance.now()
                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    wasmIface.edge_detection()
                    const addr = wasmIface.currentImgAddress()
                    const imgArray = new Uint8ClampedArray(wasmIface.memory.buffer, addr, imgData.data.length)

                    const newImgData = new ImageData(imgArray, imgData.width, imgData.height)
                    context.putImageData(newImgData, 0, 0)
                    const execSpan = document.getElementById('exec-time')
                    execSpan.innerHTML = performance.now() - start
                }

                function convolution(kernel) {
                    const start = performance.now()
                    const imgData = context.getImageData(0, 0, canvas.width, canvas.height);

                    const newImageData = context.createImageData(imgData);

                    const maxX = imgData.width - 1
                    const maxY = imgData.height - 1

                    function avgPixels(imgData, pixelCoords, kernel) {
                        const newPixel = { r: 0, g: 0, b: 0, a: 255 } // 255 alpha is temporal...
                        for (let idx = 0; idx < pixelCoords.length; idx += 1) {
                            const actCoord = pixelCoords[idx]
                            const actKernel = kernel[idx]
                            const actPixel = getPixel(imgData, actCoord.x, actCoord.y)
                            newPixel.r += actKernel * actPixel.r
                            newPixel.g += actKernel * actPixel.g
                            newPixel.b += actKernel * actPixel.b
                        }

                        return newPixel
                    }
                    // corners
                    /*
                        kernel matrix help:

                        [
                            kernel[0], kernel[1], kernel[2],
                            kernel[3], kernel[4], kernel[5],
                            kernel[6], kernel[7], kernel[8]
                        ]
                    */
                    // top-left
                    setPixel(newImageData, 0, 0, avgPixels(imgData, [
                        { x: 0, y: 0 },
                        { x: 0, y: 1 },
                        { x: 1, y: 0 },
                        { x: 1, y: 1 }
                    ], [kernel[4], kernel[7], kernel[5], kernel[8]]))
                    // top-right
                    setPixel(newImageData, maxX, 0, avgPixels(imgData, [
                        { x: maxX, y: 0 },
                        { x: maxX, y: 1 },
                        { x: maxX - 1, y: 0 },
                        { x: maxX - 1, y: 1 }
                    ], [kernel[4], kernel[7], kernel[3], kernel[6]]))
                    // bottom-left
                    setPixel(newImageData, 0, maxY, avgPixels(imgData, [
                        { x: 0, y: maxY },
                        { x: 0, y: maxY - 1 },
                        { x: 1, y: maxY },
                        { x: 1, y: maxY - 1 }
                    ], kernel[4], kernel[1], kernel[5], kernel[2]))
                    // bottom-right
                    setPixel(newImageData, maxX, maxY, avgPixels(imgData, [
                        { x: maxX, y: maxY },
                        { x: maxX, y: maxY - 1 },
                        { x: maxX - 1, y: maxY },
                        { x: maxX - 1, y: maxY - 1 }
                    ], kernel[4], kernel[1], kernel[3], kernel[0]))

                    // edges
                    // top & bottom
                    for (let cIdx = 1; cIdx < maxX; cIdx += 1) {
                        const topIndices = [
                            { x: cIdx - 1, y: 0 },
                            { x: cIdx, y: 0 },
                            { x: cIdx + 1, y: 0 },
                            { x: cIdx - 1, y: 1 },
                            { x: cIdx, y: 1 },
                            { x: cIdx + 1, y: 1 }
                        ]
                        setPixel(newImageData, cIdx, 0, avgPixels(imgData, topIndices, [
                            kernel[3], kernel[4], kernel[5], kernel[6], kernel[7], kernel[8]
                        ]))

                        const bottomIndices = [
                            { x: cIdx - 1, y: maxY - 1 },
                            { x: cIdx, y: maxY - 1 },
                            { x: cIdx + 1, y: maxY - 1 },
                            { x: cIdx - 1, y: maxY },
                            { x: cIdx, y: maxY },
                            { x: cIdx + 1, y: maxY }
                        ]
                        setPixel(newImageData, cIdx, maxY, avgPixels(imgData, bottomIndices, [
                            kernel[0], kernel[1], kernel[2], kernel[3], kernel[4], kernel[5]
                        ]))
                    }
                    // left & right
                    for (let rIdx = 0; rIdx < maxY; rIdx += 1) {
                        const leftIndices = [
                            { x: 0, y: rIdx - 1 },
                            { x: 0, y: rIdx },
                            { x: 0, y: rIdx + 1 },
                            { x: 1, y: rIdx - 1 },
                            { x: 1, y: rIdx },
                            { x: 1, y: rIdx + 1 }
                        ]
                        setPixel(newImageData, 0, rIdx, avgPixels(imgData, leftIndices, [
                            kernel[1], kernel[2], kernel[4], kernel[5], kernel[7], kernel[8]
                        ]))

                        const rightIndices = [
                            { x: maxX - 1, y: rIdx - 1 },
                            { x: maxX - 1, y: rIdx },
                            { x: maxX - 1, y: rIdx + 1 },
                            { x: maxX, y: rIdx - 1 },
                            { x: maxX, y: rIdx },
                            { x: maxX, y: rIdx + 1 }
                        ]
                        setPixel(newImageData, maxX, rIdx, avgPixels(imgData, rightIndices, [
                            kernel[0], kernel[1], kernel[3], kernel[4], kernel[6], kernel[7]
                        ]))
                    }


                    // middle part
                    for (let rIdx = 1; rIdx < maxY; rIdx += 1) {
                        for (let cIdx = 1; cIdx < maxX; cIdx += 1) {
                            const indices = [
                                { y: rIdx - 1, x: cIdx - 1},
                                { y: rIdx - 1, x: cIdx},
                                { y: rIdx - 1, x: cIdx + 1},
                                { y: rIdx, x: cIdx - 1},
                                { y: rIdx, x: cIdx},
                                { y: rIdx, x: cIdx + 1},
                                { y: rIdx + 1, x: cIdx - 1},
                                { y: rIdx + 1, x: cIdx},
                                { y: rIdx + 1, x: cIdx + 1}
                            ]
                            setPixel(newImageData, cIdx, rIdx, avgPixels(imgData, indices, kernel))
                        }
                    }

                    context.putImageData(newImageData, 0, 0)
                    const execSpan = document.getElementById('exec-time')
                    execSpan.innerHTML = performance.now() - start
                }

                function blur2() {
                    const kernel = [
                        0.1, 0.1, 0.1,
                        0.1, 0.2, 0.1,
                        0.1, 0.1, 0.1
                    ]

                    convolution(kernel)
                }

                function edgeDetection2() {
                    const kernel = [
                        -1, -1, -1,
                        -1, 8, -1,
                        -1, -1, -1
                    ]

                    convolution(kernel)
                }

                function sharpen2() {
                    const kernel = [
                        0, -1, 0,
                        -1, 5, -1,
                        0, -1, 0
                    ]

                    convolution(kernel)
                }


                document.getElementById('invert-js').onclick = invert2
                document.getElementById('grayscale-js').onclick = toGrayscale2
                document.getElementById('blur-js').onclick = blur2
                document.getElementById('sharpen-js').onclick = sharpen2
                document.getElementById('edge-js').onclick = edgeDetection2

                document.getElementById('invert-zig').onclick = invert
                document.getElementById('grayscale-zig').onclick = toGrayscale
                document.getElementById('blur-zig').onclick = blur
                document.getElementById('sharpen-zig').onclick = sharpen
                document.getElementById('edge-zig').onclick = edgeDetection
            }
            main()
        </script>
    </body>
</html>